<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interpolation Terminology Alert</title>

    <!-- React and ReactDOM -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>

    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- Recharts for visualization -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/recharts/2.10.3/Recharts.min.js"></script>

    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
        }
        .container {
            max-width: 100%;
            padding: 20px;
        }
        canvas {
            max-width: 100%;
            height: auto;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        const InterpolationExplorer = () => {
          // State for managing data points and visualization
          const [points, setPoints] = useState([
            { x: 100, y: 300 },
            { x: 300, y: 100 },
            { x: 500, y: 350 },
          ]);
          const [method, setMethod] = useState('linear');
          const [isAdding, setIsAdding] = useState(false);
          const [showExplanation, setShowExplanation] = useState(true);
          const canvasRef = useRef(null);
          const [hoverX, setHoverX] = useState(null);
          const [hoverValue, setHoverValue] = useState(null);
          const [isPredicting, setIsPredicting] = useState(false);
          const [targetX, setTargetX] = useState(250);
          const [userPrediction, setUserPrediction] = useState('');
          const [feedbackMessage, setFeedbackMessage] = useState('');
          const [showAnswer, setShowAnswer] = useState(false);

          // Sort points by x-coordinate
          const sortedPoints = [...points].sort((a, b) => a.x - b.x);

          // Canvas dimensions
          const width = 600;
          const height = 400;
          const padding = 40;

          // Linear interpolation function
          const linearInterpolate = (x, points) => {
            // Find the two points that x is between
            for (let i = 0; i < points.length - 1; i++) {
              if (x >= points[i].x && x <= points[i+1].x) {
                const x1 = points[i].x;
                const y1 = points[i].y;
                const x2 = points[i+1].x;
                const y2 = points[i+1].y;

                // Linear interpolation formula: y = y1 + (x - x1) * (y2 - y1) / (x2 - x1)
                return y1 + (x - x1) * (y2 - y1) / (x2 - x1);
              }
            }
            return null;
          };

          // Nearest neighbor interpolation
          const nearestNeighbor = (x, points) => {
            if (points.length === 0) return null;

            // Find the closest point
            let closest = points[0];
            let minDistance = Math.abs(x - closest.x);

            for (let i = 1; i < points.length; i++) {
              const distance = Math.abs(x - points[i].x);
              if (distance < minDistance) {
                minDistance = distance;
                closest = points[i];
              }
            }

            return closest.y;
          };

          // Polynomial interpolation using Lagrange method
          const polynomialInterpolate = (x, points) => {
            if (points.length <= 1) return points.length === 1 ? points[0].y : null;

            let result = 0;
            for (let i = 0; i < points.length; i++) {
              let term = points[i].y;
              for (let j = 0; j < points.length; j++) {
                if (i !== j) {
                  term = term * (x - points[j].x) / (points[i].x - points[j].x);
                }
              }
              result += term;
            }
            return result;
          };

          // Get interpolated value based on selected method
          const getInterpolatedValue = (x) => {
            if (sortedPoints.length < 2) return null;

            // Only interpolate between the first and last points
            if (x < sortedPoints[0].x || x > sortedPoints[sortedPoints.length - 1].x) {
              return null;
            }

            switch (method) {
              case 'linear':
                return linearInterpolate(x, sortedPoints);
              case 'nearest':
                return nearestNeighbor(x, sortedPoints);
              case 'polynomial':
                return polynomialInterpolate(x, sortedPoints);
              default:
                return null;
            }
          };

          // Draw the canvas
          useEffect(() => {
            const canvas = canvasRef.current;
            if (!canvas) return;

            const ctx = canvas.getContext('2d');

            // Clear canvas
            ctx.clearRect(0, 0, width, height);

            // Draw grid
            ctx.strokeStyle = '#ddd';
            ctx.lineWidth = 0.5;

            // Draw vertical grid lines
            for (let x = padding; x <= width - padding; x += 50) {
              ctx.beginPath();
              ctx.moveTo(x, padding);
              ctx.lineTo(x, height - padding);
              ctx.stroke();

              // Draw x-axis labels
              ctx.fillStyle = '#666';
              ctx.font = '12px Arial';
              ctx.textAlign = 'center';
              ctx.fillText(x.toString(), x, height - padding/2);
            }

            // Draw horizontal grid lines
            for (let y = padding; y <= height - padding; y += 50) {
              ctx.beginPath();
              ctx.moveTo(padding, y);
              ctx.lineTo(width - padding, y);
              ctx.stroke();

              // Draw y-axis labels
              ctx.fillStyle = '#666';
              ctx.font = '12px Arial';
              ctx.textAlign = 'right';
              ctx.fillText((height - y).toString(), padding - 10, y + 4);
            }

            // Draw x and y axes
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(padding, height - padding);
            ctx.lineTo(width - padding, height - padding);
            ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(padding, height - padding);
            ctx.lineTo(padding, padding);
            ctx.stroke();

            // Draw data points
            ctx.fillStyle = '#3498db';
            points.forEach(point => {
              ctx.beginPath();
              ctx.arc(point.x, point.y, 8, 0, Math.PI * 2);
              ctx.fill();
            });

            // Highlight prediction point if in predicting mode
            if (isPredicting) {
              ctx.fillStyle = '#e74c3c';
              ctx.beginPath();
              ctx.arc(targetX, height - padding, 8, 0, Math.PI * 2);
              ctx.fill();
              ctx.fillStyle = '#000';
              ctx.font = '14px Arial';
              ctx.textAlign = 'center';
              ctx.fillText(`Find y when x = ${targetX}`, targetX, height - padding + 20);
            }

            // Draw interpolation curve
            if (sortedPoints.length >= 2) {
              ctx.strokeStyle = getMethodColor();
              ctx.lineWidth = 3;
              ctx.beginPath();

              const startX = sortedPoints[0].x;
              const endX = sortedPoints[sortedPoints.length - 1].x;

              ctx.moveTo(startX, linearInterpolate(startX, sortedPoints));

              for (let x = startX; x <= endX; x += 2) {
                const y = getInterpolatedValue(x);
                if (y !== null) {
                  ctx.lineTo(x, y);
                }
              }

              ctx.stroke();
            }

            // Draw hover indicator
            if (hoverX !== null && hoverValue !== null) {
              const circleRadius = 6;
              ctx.fillStyle = 'rgba(255, 0, 0, 0.7)';
              ctx.beginPath();
              ctx.arc(hoverX, hoverValue, circleRadius, 0, Math.PI * 2);
              ctx.fill();

              ctx.fillStyle = '#000';
              ctx.font = '14px Arial';
              ctx.textAlign = 'center';
              ctx.fillText(`(${hoverX}, ${Math.round(height - hoverValue)})`, hoverX, hoverValue - 15);
            }

            // Show the actual answer in prediction mode if requested
            if (isPredicting && showAnswer) {
              const actualY = getInterpolatedValue(targetX);
              if (actualY !== null) {
                ctx.fillStyle = '#27ae60';
                ctx.beginPath();
                ctx.arc(targetX, actualY, 8, 0, Math.PI * 2);
                ctx.fill();

                ctx.fillStyle = '#000';
                ctx.font = '14px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(`Actual y = ${Math.round(height - actualY)}`, targetX, actualY - 15);
              }
            }
          }, [points, method, hoverX, hoverValue, isPredicting, targetX, showAnswer]);

          // Handle canvas click to add points
          const handleCanvasClick = (e) => {
            if (!isAdding) return;

            const canvas = canvasRef.current;
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            // Only add points within the plotting area
            if (x >= padding && x <= width - padding && y >= padding && y <= height - padding) {
              setPoints([...points, { x, y }]);
            }
          };

          // Handle canvas mouse move for hover indicator
          const handleCanvasMouseMove = (e) => {
            if (sortedPoints.length < 2) {
              setHoverX(null);
              setHoverValue(null);
              return;
            }

            const canvas = canvasRef.current;
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;

            const startX = sortedPoints[0].x;
            const endX = sortedPoints[sortedPoints.length - 1].x;

            if (x >= startX && x <= endX) {
              const interpolatedY = getInterpolatedValue(x);
              if (interpolatedY !== null) {
                setHoverX(x);
                setHoverValue(interpolatedY);
                return;
              }
            }

            setHoverX(null);
            setHoverValue(null);
          };

          // Reset the canvas
          const resetCanvas = () => {
            setPoints([]);
            setIsAdding(false);
            setIsPredicting(false);
            setShowAnswer(false);
            setFeedbackMessage('');
            setUserPrediction('');
          };

          // Get color for current interpolation method
          const getMethodColor = () => {
            switch (method) {
              case 'linear': return '#3498db';
              case 'nearest': return '#e74c3c';
              case 'polynomial': return '#27ae60';
              default: return '#3498db';
            }
          };

          // Get comprehensive explanation for the method
          const getExplanation = () => {
            switch (method) {
              case 'linear':
                return (
                  <div>
                    <p className="font-bold">Linear Interpolation:</p>
                    <p>• Simple: It's like connecting dots with a ruler!</p>
                    <p>• Concept: Values change at a constant rate between known points, creating straight line segments.</p>
                    <p>• Formula: y = y₁ + (x - x₁) × (y₂ - y₁) ÷ (x₂ - x₁)</p>
                    <p>• Key Terms: slope, line segment, linear function, proportional change</p>
                  </div>
                );
              case 'nearest':
                return (
                  <div>
                    <p className="font-bold">Nearest Neighbor Interpolation:</p>
                    <p>• Simple: It finds the closest known point and uses that value.</p>
                    <p>• Concept: Creates a step-like graph where values change suddenly at the halfway point between known values.</p>
                    <p>• Formula: f(x) = y₁ where point (x₁,y₁) has the smallest distance |x-x₁|</p>
                    <p>• Key Terms: proximity, step function, discontinuous, piecewise constant</p>
                  </div>
                );
              case 'polynomial':
                return (
                  <div>
                    <p className="font-bold">Polynomial Interpolation:</p>
                    <p>• Simple: It draws a smooth curve that passes through every point exactly.</p>
                    <p>• Concept: Creates a single smooth curve with continuously changing slope throughout.</p>
                    <p>• Technical: Uses Lagrange polynomials to create a function that passes through all points.</p>
                    <p>• Key Terms: curve fitting, Lagrange polynomial, smooth function, continuous derivative</p>
                  </div>
                );
            }
          };

          // Check user's prediction
          const checkPrediction = () => {
            if (!userPrediction) {
              setFeedbackMessage("Please enter your prediction!");
              return;
            }

            const prediction = parseFloat(userPrediction);
            if (isNaN(prediction)) {
              setFeedbackMessage("Please enter a valid number!");
              return;
            }

            const actualY = Math.round(height - getInterpolatedValue(targetX));
            const difference = Math.abs(prediction - actualY);

            if (difference <= 5) {
              setFeedbackMessage("Great job! Your prediction is very close!");
            } else if (difference <= 15) {
              setFeedbackMessage("Good try! You're in the right ballpark!");
            } else {
              setFeedbackMessage("Try again! Hint: Look at the pattern of the points.");
            }

            setShowAnswer(true);
          };

          // Start a prediction challenge
          const startPrediction = () => {
            if (sortedPoints.length < 2) {
              alert("You need at least 2 points to make a prediction!");
              return;
            }

            // Find a random x-value between the first and last point
            const startX = sortedPoints[0].x;
            const endX = sortedPoints[sortedPoints.length - 1].x;
            const randomX = Math.floor(startX + Math.random() * (endX - startX));

            setTargetX(randomX);
            setIsPredicting(true);
            setShowAnswer(false);
            setUserPrediction('');
            setFeedbackMessage('');
          };

          return (
            <div className="flex flex-col items-center p-4 bg-gray-50 rounded-lg shadow">
              <h1 className="text-2xl font-bold mb-4">Interpolation Terminology Alert</h1>

              {/* Controls */}
              <div className="flex flex-wrap justify-center gap-4 mb-4">
                <div className="flex items-center">
                  <label className="mr-2 font-medium">Method:</label>
                  <select
                    value={method}
                    onChange={(e) => setMethod(e.target.value)}
                    className="border rounded p-1"
                  >
                    <option value="linear">Linear</option>
                    <option value="nearest">Nearest Neighbor</option>
                    <option value="polynomial">Polynomial</option>
                  </select>
                </div>

                <button
                  className={`px-3 py-1 rounded ${isAdding ? 'bg-green-500 text-white' : 'bg-blue-500 text-white'}`}
                  onClick={() => setIsAdding(!isAdding)}
                >
                  {isAdding ? 'Done Adding' : 'Add Points'}
                </button>

                <button
                  className="px-3 py-1 rounded bg-red-500 text-white"
                  onClick={resetCanvas}
                >
                  Reset
                </button>

                <button
                  className="px-3 py-1 rounded bg-purple-500 text-white"
                  onClick={startPrediction}
                  disabled={isPredicting}
                >
                  Practice!
                </button>
              </div>

              {/* Explanation Box */}
              {showExplanation && (
                <div className="mb-4 p-4 bg-yellow-100 rounded">
                  <div className="flex justify-between items-start mb-2">
                    <h3 className="text-lg font-bold">Terminology & Explanation</h3>
                    <button
                      className="text-sm text-blue-500 underline"
                      onClick={() => setShowExplanation(false)}
                    >
                      Hide Explanation
                    </button>
                  </div>
                  <div className="bg-white p-3 rounded shadow-inner">
                    {getExplanation()}
                  </div>
                </div>
              )}

              {!showExplanation && (
                <button
                  className="mb-4 text-sm text-blue-500 underline"
                  onClick={() => setShowExplanation(true)}
                >
                  Show Terminology
                </button>
              )}

              {/* Canvas */}
              <div className="relative mb-4">
                <canvas
                  ref={canvasRef}
                  width={width}
                  height={height}
                  onClick={handleCanvasClick}
                  onMouseMove={handleCanvasMouseMove}
                  className="border border-gray-300"
                />

                {isAdding && (
                  <div className="absolute top-2 left-2 bg-white p-2 rounded shadow">
                    Click to add points
                  </div>
                )}
              </div>

              {/* Prediction Challenge */}
              {isPredicting && (
                <div className="mt-4 p-4 bg-blue-100 rounded flex flex-col items-center">
                  <h3 className="text-lg font-bold mb-2">Prediction Challenge!</h3>
                  <p>Using the {method} interpolation method, what do you think the y-value is at x = {targetX}?</p>

                  <div className="flex items-center mt-2">
                    <input
                      type="number"
                      value={userPrediction}
                      onChange={(e) => setUserPrediction(e.target.value)}
                      className="border rounded p-1 mr-2"
                      placeholder="Your prediction"
                    />
                    <button
                      className="px-3 py-1 rounded bg-green-500 text-white"
                      onClick={checkPrediction}
                    >
                      Check
                    </button>
                  </div>

                  {feedbackMessage && (
                    <p className="mt-2 font-bold text-center">{feedbackMessage}</p>
                  )}

                  <div className="mt-2 flex gap-2">
                    <button
                      className="px-3 py-1 rounded bg-gray-300"
                      onClick={() => {
                        setShowAnswer(true);
                        setFeedbackMessage("The answer is shown on the graph!");
                      }}
                    >
                      Show Answer
                    </button>
                    <button
                      className="px-3 py-1 rounded bg-red-500 text-white"
                      onClick={() => {
                        setIsPredicting(false);
                        setShowAnswer(false);
                        setFeedbackMessage('');
                      }}
                    >
                      Exit Challenge
                    </button>
                  </div>
                </div>
              )}

              {/* Instructions */}
              <div className="mt-4 p-4 bg-gray-100 rounded w-full max-w-lg">
                <h3 className="text-lg font-bold mb-2">How to use:</h3>
                <ol className="list-decimal pl-5">
                  <li>Click "Add Points" and then click on the graph to add data points</li>
                  <li>Choose different interpolation methods to see how they work</li>
                  <li>Read the terminology explanations for each method</li>
                  <li>Hover over the line to see values at any point</li>
                  <li>Use "Practice!" to test your understanding</li>
                </ol>
              </div>

              <div className="mt-4 text-sm text-center text-gray-500">
                <p>Created by the Coastal Hydrology Lab</p>
                <p>Contributors: Faezeh Maghsoodifar, Michael Lewis, and Dr. Hamed Moftakhari</p>
              </div>
            </div>
          );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<InterpolationExplorer />);
    </script>

    <!-- Babel for JSX transformation -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.22.20/babel.min.js"></script>
</body>
</html>